TODO:
  
COMPILATION:
I control which main file is visible through define_main.h, see the file
You can find the binary in XCOSE by going to the project navigator
  at the bottom is the binary, right click > show in Finder
  at the bottom right, right click > copy as pathname

MEMORY LEAKS
use the zsh command line "leaks" tool
run:
% cd
  /Users/benharki/Library/Developer/Xcode/DerivedData/Data_Structures_C-cigihujjgmcqyzbnhasuwqlbgnfb/Build/Products/Debug
% leaks --quiet --atExit -- ./Data_Structures_C

XCODE:
You have to pick one file with a main() function to run
The other main functions are renamed file_main()
  when they are not currently used to test
Any new main functions need to have Data_Structures_C selected as the target binary
  you can do this in the top right icon, select Target Membership


Remarks about generic types:
  one macro generating a data structure for different types
    basically means you are only writing in macros
  using void pointers eventually forces you to cast to a type
    I tried this but it led me to writing a Type class and read
      and write functions, which then became "non-C"
  DID THIS: one solution would be to use char* and void*, since you
    can cast to char*, and its of size 1 byte
    unsigned char may be better since it is less dependent on
      implementation
    causes all the type pointer arithmetic to turn into
      type_size * size
    can't read/write to void* but you can unsigned char*
  Solution may be to write one concrete class with an ITEM_TYPE
    this allows exactly one class with any type of your choosing
    can copy this class and rename for more than one concreate
      structure usable with different types
  You can turn this ITEM_TYPE solution pretty easily into a macro
    so if you debug one then you only have to debug one more which
      isn't that bad
    can simplify this by ordering it a way that allows removing
      function prototypes, since its generated in the main file
    Basically copy into macro like this:
      struct definition
      non-constructor functions
        constructor will assign other functions as "methods"
      constructor function
    Need to copy/paste ITEM_TYPE##_ to each func/struct
      name
    macro has to append TYPE via ## to each name:
      new struct name in the def
      the new struct name in each of the method pointer args
      the new typedef name
      each new function name and first arg for the new typedef
        name
      each function return that returns a new typedef name
      inside the constructor, in new typedef name, and
        assigning functions to the method pointers
    Easiest way to do this: use the search replace in text editor
      replace old struct name with new appended struct name
      replace old typedef name with new appended typedef name
      replace ; with ; \
      add the other ends of lines with \
      replace the function names manually
    removing the "methods" for each struct might make the macro easier
      to write, but would make the functions called on the struct
      difficult to call with tests, since they would have different
        names per type

TESTING
My Testing philosopy is to exhaustively check the state of
  each structure at specific points with small examples
It should check the state at least once after each
  execution branch finishes for each of its functions
I am assuming that if a bug is found in a more complex
   usage of a structure that it would hopefully be found
   first in one of the small tests
Each test does not create a seperate structure obj to test,
  rather it tests one (or a few) as it changes over
  time, when they are set up for the next test
It takes too much time to test very complex examples with
  large structures

TEXT NOTES

1.1 Stack
Stacks collect data and only remove from the top (usually)
operations:
  push on the the top of the stack
  pop return the top and remove it
  empty to check if it is empty
canoncical implementaion on an ideal machine (turing?)
  no pop on empty
  infinite memory (tape) for the stack
a realistic stack is one with fixed array memory:
  returns an error on push on stack overflow
  downfall: size needs to be decided in advance
  overflow error here is generated by the structure
    but is not a part of the ideal version
pop underflow would be an error generated by improper use
  so its not shown here
  also would have to return both the object and the error status
generally includes security checks that test for errors 
  introduced by the limitations of the implementation
  rather than those introduced by the ideal version
  always assume that the use of the stack is correct and that
    you never run out of memory
to make it dynamic need to create and remove stack operations
  use a struct
include operation to look at the top without removal
as a dynamically allocated linked list:
  insert and delete from the front of the list
  not of fixed size, so no need to address stack overflow
  malloc is not guaranteed to be constant, so this version 
    uses more simplified memory management functions:
    get_node and return_node  
(section 1.4) get_node and return_node are used in place of malloc and free
  malloc and free should be used for large arbitrary allocations of memory
    they are not guaranteed to be constant
  get_node and return_node should create and delete constant sized 
    memory objects
  adds an intermediate layer that only occasinally accesses OS
    memory management free and malloc
    it also gives out an recieves back small constant sized chunks of mem
    does not return memory to the system before the program ends
    intermediate layer takes the maximum amount needed for the data
      structure up to that moment
    only fails to free it earlier for other programs or structures
    free_list contains all nodes not currently in use
    return_node add the node to the free list
    get_node
      if the free list is not empty take a node from there
      if it is and the current mem block is not used up
        take a node from there
      otherwise get a new memory block with malloc and create a node
    can use a valid integer flag to determine whether it has been
      recieved back by return_node or given out by get_node  
