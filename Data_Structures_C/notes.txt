TODO:
Implement linked_stack files since the node memory manager is set up
  and passes tests
Add the node manager pointer to the linked stack struct
Fix the global struct, function, and typedef names
  USE MACROS?

COMPILATION:
I control which main file is visible through define_main.h, see the file
You can find the binary in XCODE by going to the project navigator
  at the bottom is the binary, right click > show in Finder
  at the bottom right, right click > copy as pathname
XCode will also find any C files in subfolders without pathing to them in includes

MEMORY LEAKS
use the zsh command line "leaks" tool
run:
% cd
  /Users/benharki/Library/Developer/Xcode/DerivedData/Data_Structures_C-cigihujjgmcqyzbnhasuwqlbgnfb/Build/Products/Debug
% leaks --quiet --atExit -- ./Data_Structures_C

XCODE:
Any new C files MUST have Data_Structures_C selected as the
  target binary
you can do this in the top right icon, select Target Membership to be the Data_Stuctures_C binary


Remarks about generic types:
  one macro generating a data structure for different types
    basically means you are only writing in macros
  using void pointers eventually forces you to cast to a type
    I tried this but it led me to writing a Type class and read
      and write functions, which then became "non-C"
  DID THIS: one solution would be to use char* and void*, since you
    can cast to char*, and its of size 1 byte
    unsigned char may be better since it is less dependent on
      implementation
    causes all the type pointer arithmetic to turn into
      type_size * size
    can't read/write to void* but you can unsigned char*
  Solution may be to write one concrete class with an ITEM_TYPE
    this allows exactly one class with any type of your choosing
    can copy this class and rename for more than one concreate
      structure usable with different types
  You can turn this ITEM_TYPE solution pretty easily into a macro
    so if you debug one then you only have to debug one more which
      isn't that bad
    can simplify this by ordering it a way that allows removing
      function prototypes, since its generated in the main file
    Basically copy into macro like this:
      struct definition
      non-constructor functions
        constructor will assign other functions as "methods"
      constructor function
    Need to copy/paste ITEM_TYPE##_ to each func/struct
      name
    macro has to append TYPE via ## to each name:
      new struct name in the def
      the new struct name in each of the method pointer args
      the new typedef name
      each new function name and first arg for the new typedef
        name
      each function return that returns a new typedef name
      inside the constructor, in new typedef name, and
        assigning functions to the method pointers
    Easiest way to do this: use the search replace in text editor
      replace old struct name with new appended struct name
      replace old typedef name with new appended typedef name
      replace ; with ; \
      add the other ends of lines with \
      replace the function names manually
    removing the "methods" for each struct might make the macro easier
      to write, but would make the functions called on the struct
      difficult to call with tests, since they would have different
        names per type
    May need to be careful of name collision across files
      Xcode seems to collide names across files for structs and
        typedefs if they are included

TESTING
My Testing philosopy is to exhaustively check the state of
  each structure at specific points with small examples
It should check the state at least once after each
  execution branch finishes for each of its functions
I am assuming that if a bug is found in a more complex
   usage of a structure that it would hopefully be found
   first in one of the small tests
Each test does not create a seperate structure obj to test,
  rather it tests one (or a few) as it changes over
  time, when they are set up for the next test
Could also check a function applied to multiple cases
  but only check the state of the structure once afterwards
It takes too much time to test very complex examples with
  large structures

TEXT NOTES

1.1 Stack
Stacks collect data and only remove from the top (usually)
operations:
  push on the the top of the stack
  pop return the top and remove it
  empty to check if it is empty
canoncical implementaion on an ideal machine (turing?)
  no pop on empty
  infinite memory (tape) for the stack
a realistic stack is one with fixed array memory:
  returns an error on push on stack overflow
  downfall: size needs to be decided in advance
  overflow error here is generated by the structure
    but is not a part of the ideal version
pop underflow would be an error generated by improper use
  so its not shown here
  also would have to return both the object and the error status
generally includes security checks that test for errors 
  introduced by the limitations of the implementation
  rather than those introduced by the ideal version
  always assume that the use of the stack is correct and that
    you never run out of memory
to make it dynamic need to create and remove stack operations
  use a struct
include operation to look at the top without removal
as a dynamically allocated linked list:
  insert and delete from the front of the list
  not of fixed size, so no need to address stack overflow
  malloc is not guaranteed to be constant, so this version 
    uses more simplified memory management functions:
    get_node and return_node  
(section 1.4) get_node and return_node are used in place of malloc and free
  malloc and free should be used for large arbitrary allocations of memory
    they are not guaranteed to be constant
  get_node and return_node should create and delete constant sized 
    memory objects
  adds an intermediate layer that only occasinally accesses OS
    memory management free and malloc
    it also gives out an recieves back small constant sized chunks of mem
    does not return memory to the system before the program ends
    intermediate layer takes the maximum amount needed for the data
      structure up to that moment
    only fails to free it earlier for other programs or structures
    free_list contains all nodes not currently in use
    return_node add the node to the free list
    get_node
      if the free list is not empty take a node from there
      if it is and the current mem block is not used up
        take a node from there
      otherwise get a new memory block with malloc and create a node
    can use a valid integer flag to determine whether it has been
      recieved back by return_node or given out by get_node  
first linked list version:
  uses get_node and return_node to replace malloc an free 
  there is a header node that serves as a stack identifier
    an unchanged by all stack operations
  remove_stack should return all remaining nodes
  avoids stack overflow and no need to predict the array 
    size in the array version
  disadvantage in dereferenceing a pointer to anywhere
    which could lead to cache misses
    array version does not have this disadvantage, works well
      with the cache,
    prefer the array version if you are certain on the max size
linked list of blocks version:
  combines advantages of linked list and array version of stack
  this is basically a linked list of arrays, stack size based
    on the array storage
  once its depleted allocate another array and connect to the filled one
    in a linked list
  one disadvantage of this version is when there are many push/pops over
    a block boundary, forcing many frees and mallocs
  I did not do this version
My intermediate layer and node  
  I did create the intermediate layer of nodes with get_node and return_node
  I modified this to allocate more space of BLOCKSIZE if its needed
  If BLOCKSIZE isn't big enough it could malloc many times
  It only calls destroy once, but that could free many blocks of BLOCKSIZE
  Would be best to make each node contain some item value, rather 
    than a void pointer to some other location to take advantage of cache hits
  this is my version of the combined advantages of the array and
    linked list version
My stack implementations from 1.1
  fixed_stacks: these are array versions of the stack
    one is set to a type, the other is more generic using void* and char*
  node: node and intermediate layer to get and return nodes, reducing malloc 
      and free calls for the linked list version
    could maybe make node a better generic using unsigned char* instead of 
      void*, like I did with generic_stack?
        prob not: if the item is a string then the item is a pointer anyways
          other types could be done this way
    might still get cache savings if the void* items points to
      many items that were alloced in a buffer together
    makes all read and write on the items a loop on each char byte
    Linked data structures will have their own Node and memory managers
      since this is more of a prototype
      each structure can have their own type of node
  linked_stack
    Regular linked list implementation, uses a node memory manager
    item data for each node is not embedded in the node
      since the data is a string, and strings can vary in size
      other types might benefit in cache hits if the item data is
        embedded in the node rather than the node containing item pointer
      if the data is embedded in the node then you have to
        change the node memory manager's malloc blocks linked list
        it takes the first node of the malloced nodes block
      may help cache if all the strings are a part of a large malloc block
    You can #include "linked_stack.h" in test_node.c to test
        its memory manager directly with its already written tests
      You only need to change its 2 calls to lstack_init_node_memory()
        could write a macro to do this more easily or even make the constructor
          a struct function to avoid collision
    Each structure needs its own memory manager for cache benefits
      even if they share they same type of node, like a single linked node
      however beware of typedef and struct name collision
        need to clean up the global struct, function, typedef names
    
