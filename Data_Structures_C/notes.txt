TODO:
  finished the linked_stack with the header node
    also uses the get_node and return_node
  
COMPILATION:
I control which main file is visible through define_main.h, see the file
You can find the binary in XCOSE by going to the project navigator
  at the bottom is the binary, right click > show in Finder
  at the bottom right, right click > copy as pathname

MEMORY LEAKS
use the zsh command line "leaks" tool
run:
% cd
  /Users/benharki/Library/Developer/Xcode/DerivedData/Data_Structures_C-cigihujjgmcqyzbnhasuwqlbgnfb/Build/Products/Debug
% leaks --quiet --atExit -- ./Data_Structures_C

XCODE:
Any new main functions need to have Data_Structures_C selected as the
  target binary
you can do this in the top right icon, select Target Membership to be the Data_Stuctures_C binary


Remarks about generic types:
  one macro generating a data structure for different types
    basically means you are only writing in macros
  using void pointers eventually forces you to cast to a type
    I tried this but it led me to writing a Type class and read
      and write functions, which then became "non-C"
  DID THIS: one solution would be to use char* and void*, since you
    can cast to char*, and its of size 1 byte
    unsigned char may be better since it is less dependent on
      implementation
    causes all the type pointer arithmetic to turn into
      type_size * size
    can't read/write to void* but you can unsigned char*
  Solution may be to write one concrete class with an ITEM_TYPE
    this allows exactly one class with any type of your choosing
    can copy this class and rename for more than one concreate
      structure usable with different types
  You can turn this ITEM_TYPE solution pretty easily into a macro
    so if you debug one then you only have to debug one more which
      isn't that bad
    can simplify this by ordering it a way that allows removing
      function prototypes, since its generated in the main file
    Basically copy into macro like this:
      struct definition
      non-constructor functions
        constructor will assign other functions as "methods"
      constructor function
    Need to copy/paste ITEM_TYPE##_ to each func/struct
      name
    macro has to append TYPE via ## to each name:
      new struct name in the def
      the new struct name in each of the method pointer args
      the new typedef name
      each new function name and first arg for the new typedef
        name
      each function return that returns a new typedef name
      inside the constructor, in new typedef name, and
        assigning functions to the method pointers
    Easiest way to do this: use the search replace in text editor
      replace old struct name with new appended struct name
      replace old typedef name with new appended typedef name
      replace ; with ; \
      add the other ends of lines with \
      replace the function names manually
    removing the "methods" for each struct might make the macro easier
      to write, but would make the functions called on the struct
      difficult to call with tests, since they would have different
        names per type

TESTING
My Testing philosopy is to exhaustively check the state of
  each structure at specific points with small examples
It should check the state at least once after each
  execution branch finishes for each of its functions
I am assuming that if a bug is found in a more complex
   usage of a structure that it would hopefully be found
   first in one of the small tests
Each test does not create a seperate structure obj to test,
  rather it tests one (or a few) as it changes over
  time, when they are set up for the next test
It takes too much time to test very complex examples with
  large structures

TEXT NOTES

1.1 Stack
Stacks collect data and only remove from the top (usually)
operations:
  push on the the top of the stack
  pop return the top and remove it
  empty to check if it is empty
canoncical implementaion on an ideal machine (turing?)
  no pop on empty
  infinite memory (tape) for the stack
a realistic stack is one with fixed array memory:
  returns an error on push on stack overflow
  downfall: size needs to be decided in advance
  overflow error here is generated by the structure
    but is not a part of the ideal version
pop underflow would be an error generated by improper use
  so its not shown here
  also would have to return both the object and the error status
generally includes security checks that test for errors 
  introduced by the limitations of the implementation
  rather than those introduced by the ideal version
  always assume that the use of the stack is correct and that
    you never run out of memory
to make it dynamic need to create and remove stack operations
  use a struct
include operation to look at the top without removal
as a dynamically allocated linked list:
  insert and delete from the front of the list
  not of fixed size, so no need to address stack overflow
  malloc is not guaranteed to be constant, so this version 
    uses more simplified memory management functions:
    get_node and return_node  
(section 1.4) get_node and return_node are used in place of malloc and free
  malloc and free should be used for large arbitrary allocations of memory
    they are not guaranteed to be constant
  get_node and return_node should create and delete constant sized 
    memory objects
  adds an intermediate layer that only occasinally accesses OS
    memory management free and malloc
    it also gives out an recieves back small constant sized chunks of mem
    does not return memory to the system before the program ends
    intermediate layer takes the maximum amount needed for the data
      structure up to that moment
    only fails to free it earlier for other programs or structures
    free_list contains all nodes not currently in use
    return_node add the node to the free list
    get_node
      if the free list is not empty take a node from there
      if it is and the current mem block is not used up
        take a node from there
      otherwise get a new memory block with malloc and create a node
    can use a valid integer flag to determine whether it has been
      recieved back by return_node or given out by get_node  
first linked list version:
  uses get_node and return_node to replace malloc an free 
  there is a header node that serves as a stack identifier
    an unchanged by all stack operations
  remove_stack should return all remaining nodes
  avoids stack overflow and no need to predict the array 
    size in the array version
  disadvantage in dereferenceing a pointer to anywhere
    which could lead to cache misses
    array version does not have this disadvantage, works well
      with the cache,
    prefer the array version if you are certain on the max size
linked list of blocks version:
  combines advantages of linked list and array version of stack
  this is basically a linked list of arrays, stack size based
    on the array storage
  once its depleted allocate another array and connect to the filled one
    in a linked list
  one disadvantage of this version is when there are many push/pops over
    a block boundary, forcing many frees and mallocs
  I did not do this version
My intermediate layer and node  
  I did create the intermediate layer of nodes with get_node and return_node
  I modified this to allocate more space of BLOCKSIZE if its needed
  If BLOCKSIZE isn't big enough it could malloc many times
  It only calls destroy once, but that could free many blocks of BLOCKSIZE
  Would be best to make each node contain some item value, rather 
    than a void pointer to some other location to take advantage of cache hits
  this is my version of the combined advantages of the array and
    linked list version
My stack implementations from 1.1
  fixed_stack: these are array versions of the stack
    one is set to a type, the other is more generic using void* and char*
  node: node and intermediate layer to get and return nodes, reducing malloc 
      and free calls for the linked list version
    could maybe make node a better generic using unsigned char* instead of 
      void*, like I did with generic_stack?
        prob not: if the item is a string then the item is a pointer anyways
          other types could be done this way
    might still get cache savings if the void* items points to
      many items that were alloced in a buffer together
    makes all read and write on the items a loop on each char byte
    
